#!/usr/bin/env python3
##########################################
# This file is generated by gitlab_maker.py
# Do not edit this file manually!
# The repo that this is generated from is found at:
# https://github.com/ICR-RSE-Group/gitalma
# Generated on: 2025-09-19
# Version = 1.2.0
##########################################
from pathlib import Path
import argparse
import datetime
import glob
import os
import requests
import subprocess
import sys
import threading
import time
import yaml
##########################################
"""-------------------------------------
GITLAB PULL SCRIPT FOR BCR-DataScienceTeam
This module downloads dynamically all the projects from gitlab and clones if absent or pulls if present.
Example inputs (all default to standard options):
gitlab.py -path /path/for/repo/bcrbioinformatics -include Team,Manuscripts,General,Projects -exclude Utils -source target --static
--help returns this message
--version returns the version
-source target is the production repo, test is the repo that is being tested and not updated
-path is the path to the root of the gitlab projects
-include: Only get whitelisted folders (comma delim)
-exclude: Exclude blacklisted folders (comma delim)
--static: does not dynamically get the projects, but updates from those existing or those included
--protocol: override default ssh clone behaviour with https
--history: report history instead of diff
--debug: outputs extra logs for debugging
--dry: report what would be done (mkdir, clone and pull) but don't do it
--status: report the status on each project, forces dry
--single: override multithreaded behaviour, stay in single thread.
-------------------------------------
"""

thisversion = "0.0.0"
gversion = "0.0.0"

def main():
    parser = argparse.ArgumentParser(description="GitLab pull or clone",
        epilog="""
        GITLAB PULL SCRIPT FOR BCR-DataScienceTeam
        This module downloads dynamically all the projects from gitlab and clones if absent or pulls if present.
        Example inputs (all default to standard options):
        git-alma --status
        """)
    parser.add_argument("--version", help="returns the version", action="store_true")
    # The main commands
    actions_help = "actions = [init, info, pull, update, clean, status, history,change,upgrade]"
    parser.add_argument("action", nargs=1, help=actions_help)
    # The paramaters that need values
    parser.add_argument("-source", help="target is the production repo, test is the repo that is being tested and not updated", type=str)
    parser.add_argument("-path", help="is the path to the root of the gitlab projects", type=str)
    parser.add_argument("-server", help="The url to gitlab or github", type=str)
    parser.add_argument("-subgroup", help="the gitlab subgroup number which is the root of the gitlab projects", type=int)
    parser.add_argument("-protocol", help="override default https clone behaviour with ssh", type=str)
    parser.add_argument("-wikis", help="Whether to look for wikis too", type=bool)
    parser.add_argument("-ignore_size", help="If > 0 a size to add to the .gitignore", type=int)

    # The flags
    parser.add_argument("--debug", help="outputs extra logs for debugging", action="store_true")
    parser.add_argument("--dry", help="report what would be done (mkdir, clone and pull) but don't do it", action="store_true")
    parser.add_argument("--single", help="override multithreaded behaviour, stay in single thread.", action="store_true")
    parser.add_argument("--root", help="run from home path no matter where in the repo you are.", action="store_true")
    parser.add_argument("--minimal", help="choose to reduce output messages", action="store_true")

    args = parser.parse_args()
    thisversion = get_local_version()
    gversion = get_github_version()
    if args.version:
        print("Local version:", thisversion)
        print("Github version:", gversion)
        exit()

    minimal = False
    if args.minimal:
        minimal = True

    start_time = datetime.datetime.now()
    cwd = os.getcwd()
    scrch = Scratch(cwd)
    if not scrch.gitalma:
        scrch.home = str(scrch.path)
    new_params = init_args(scrch, args)
    repo_params = init_check_get(scrch,new_params)
    #########################################################################################
    if args.action[0] == "init":
        if scrch.gitalma:
            print("Already initialised in", scrch.home)
            exit()
        elif scrch.gitalmaparent:
            print("Can't init parent - there are child gitalma repositories below this")
            exit()
        else:
            changed_params = init_save(new_params, repo_params)
            init_print(changed_params, init=True)
            exit()
    #########################################################################################
    if not scrch.gitalma:
        print("Not in a gitalma repository")
        if scrch.working.endswith("/bcrbioinformatics"):
            print("Initialising gitalma repository")
            params = {"path": scrch.working,
                      "home": scrch.working,
                      "subgroup":2879,
                      "source":"icr",
                      "server":"https://git.icr.ac.uk",
                      "protocol":"pat"}
            params = init_save(params, params)
            init_print(params, init=True)
            exit()
        else:
            exit()
    new_params = init_args(scrch, args)
    cmd_params = cmd_args(args)
    repo_params = init_check_get(scrch,new_params)
    clone_params = gl_clone_args(args,cmd_params)
    params = {}
    for key in cmd_params:
        params[key] = cmd_params[key]
    for key in repo_params:
        params[key] = repo_params[key]
    for key in clone_params:
        params[key] = clone_params[key]
    if "wikis" not in params:
        params["wikis"] = False
    if "ignore_size" not in params:
        params["ignore_size"] = 100000000
    if args.debug:
        print("===========================================")
        print("===== GIT-ALMA from the ICR RSE Team =====")
        print("===========================================")
        print("-Config repo params-")
        for key in repo_params:
            print(f"\t{key}: {repo_params[key]}")
        print("-Params entered-")
        for key in clone_params:
            print(f"\t{key}: {clone_params[key]}")
        print("=====================================")
    elif not minimal:
        print("\n===== GITALMA from the ICR RSE Team =====")
        if "repo" in repo_params:
            print(f"repo: {repo_params['repo']}")
        elif "server" in repo_params:
            print(f"server: {repo_params['server']}")
        if "path" in repo_params:
            print(f"path: {repo_params['path']}")
        print("Local/latest versions:", thisversion, "/", gversion)
        print("=====================================")

    #########################################################################################
    if args.root:
        params["path"] = params["home"]
        scrch = Scratch(params["path"])
    if args.action[0] == "info":
        init_print(repo_params, init=False)
    elif args.action[0] == "update":
        if params["source"] in ["gitlab","icr"]:
            print(f">> Check projects to delete --- ")
            all_projects,archived = gl_clone_clean(params, args.dry)
            to_clone, to_pull = gl_clone_projects(params, args.dry, args.debug, all_projects)
        else:
            to_clone, to_pull = gh_clone_projects(params, args.dry, args.debug)
        if to_clone != []:
            print(f">> Cloning {len(to_clone)} projects --- ")
            git_clone_all(params, args.dry, args.debug, to_clone)
        if to_pull != []:
            print(f">> Pulling {len(to_pull)} projects --- ")
            git_pull_all(params, "pull", args.dry, args.debug, to_pull, params["ignore_size"])
    elif args.action[0] == "pull":
        print(f">> Pull projects---")
        git_pull_all(params, "pull", args.dry, args.debug,None, None)
    elif args.action[0] == "clean":
        gl_clone_clean(params, args.dry)
    elif args.action[0] == "status":
        print(f">> Status projects---")
        git_pull_all(params, "status", args.dry, args.debug,None,None)
    elif args.action[0] == "history":
        print(f">> History projects---")
        git_pull_all(params, "history", args.dry, args.debug, None,None)
    elif args.action[0] == "filesize":
        print(f">> File-size projects---")
        git_pull_all(params, "filesize", args.dry, args.debug, None,params["ignore_size"])
    elif args.action[0] == "gitignore":
        print(f">> Git-ignore projects---")
        git_pull_all(params, "gitignore", args.dry, args.debug, None,params)
    elif args.action[0] == "change":
        if args.protocol:
            if not minimal:
                print(f">> Changing to {args.protocol}")
            token = None
            api = None
            if args.protocol == "pat" or params["source"] in ["gitlab","icr"]:
                api = GitLabAPI(params["subgroup"], params["server"], params["wikis"], minimal)
                token = api.token
            git_change_protocol(params, args.protocol, args.dry, args.debug,token, minimal=minimal)
            changed_params = init_save(params, params, api)

        else:
            if not minimal:
                print(f">> No change supplied, exiting")

    #----------------------------------------------------
    end_time = datetime.datetime.now()
    if not minimal:
        print("=====================================")
        print("Completed in ", end_time-start_time)


##########################################

class GitHubAPI:
    def __init__(self, repos, server):
        self.projects = []
        for repo in repos:
            for key,val in repo.items():
                print(key,val)
                pr_nm = val.split("/")[-1].replace(".git","")
                self.projects.append((val,0,key + "/" + pr_nm))


    def list_projects(self):
        return self.projects


    ##################################################################################

##########################################

class GitLabAPI:
    def __init__(self, group_id, server, iswikis, minimal):
        self.repo = ""
        self.group_id = int(group_id)
        self.repo_len = 0
        self.url = server
        self.iswikis = iswikis
        home = str(Path.home())

        if "icr.ac.uk" in server:
            token_path = home + "/gitlab_token.txt"
        else:
            token_path = f"{home}/{server.replace('/','').replace('https','').replace(':','').replace('.','')}_gitalma_token.txt"

        if not os.path.exists(token_path):
            print("You need to generate a gitlab personal token and save it to:")
            print("Toekn path=", token_path)
            print("See here for how to generate a token:")
            print("https://docs.gitlab.com/ee/user/profile/personal_access_tokens.html")
            self.ok = False
            exit()
        else:
            with open(token_path, 'r') as f:
                self.token = f.read().strip()
            self.headers = {
                "PRIVATE-TOKEN": self.token
            }
            self.repo = ""
            self.repo_len = 0
            if int(group_id) != -1:
                self.repo = self.get_repo_from_id(group_id, minimal)
                if self.repo == None:
                    print("Group ID not found")
                    exit()
                self.repo_len = len(self.repo.split("/"))
    ##################################################################################
    def get_id_repo(self):
        return self.group_id, self.repo
    ##################################################################################
    def list_projects(self,):
        """List all projects in the GitLab instance."""
        projects = []
        arch_projects = []
        urls = [f"{self.url}/api/v4/groups/{self.group_id}/projects"]
        #if self.iswikis:
        #    urls.append(f"{self.url}/api/v4/groups/{self.group_id}/wikis")
        try:
            for gitlab_url in urls:
                page_int = 0
                got_pages = True
                print("Fetching projects for", gitlab_url, end=" ", flush=True)
                while got_pages:
                    got_pages = False
                    page_int += 1
                    print("...", end="", flush=True)
                    response = requests.get(gitlab_url, headers=self.headers, data={"per_page":100,"page": page_int, "include_subgroups" : True})
                    response.raise_for_status()
                    current_path = ""
                    if response.status_code == 200:
                        if len(response.json()) == 0:
                            print("")
                        for val in response.json():
                            proj_id = val["id"]
                            http_url_to_repo = val["http_url_to_repo"]
                            path_with_namespace = val["path_with_namespace"]
                            archived = val["archived"]
                            if archived:
                                arch_projects.append((http_url_to_repo, proj_id,path_with_namespace))
                            else:
                                projects.append((http_url_to_repo, proj_id,path_with_namespace))
                            got_pages = True
                    else:
                        print("Failed to fetch projects: ",response.status_code)

            # Try adding wikis if requested
            if self.iswikis:
                print("Fetching wikis for", gitlab_url, flush=True)
                wiki_projects = []
                for project in projects:
                    url = project[0]
                    proj_id = project[1]
                    ppath = project[2]
                    gitlab_url = f"{self.url}/api/v4/projects/{proj_id}/wikis"
                    pages = 0
                    response = requests.get(gitlab_url, headers=self.headers, data={"per_page":100,"page": 1})
                    if response.status_code == 200:
                        for val in response.json():
                            pages += 1
                    if pages > 0:
                        #print("wiki for project ID:", proj_id, project[2])
                        gpath_wiki = f"{ppath}.wiki"
                        wiki_url = url.replace(".git", ".wiki.git")
                        wiki_projects.append((wiki_url, proj_id, gpath_wiki))

                for wp in wiki_projects:
                    projects.append(wp)
            return projects, arch_projects
        except Exception as e:
            print("!!! Failed to fetch projects: ",e)
            if e.response.status_code == 401:
                print("!!! Your Gitlab API token might be expired !!!")
            print("!!! Not safe to continue, exiting !!!")
            exit()
    ##################################################################################
    def get_repo_from_id(self, group_id, minimal):
        gitlab_url = f"{self.url}/api/v4/groups/{group_id}"
        response = requests.get(gitlab_url, headers=self.headers, data={"include_subgroups" : False, "with_projects" : False})
        if response.status_code == 200:
            if not minimal:
                print("Group ID:",group_id,"is",response.json()["full_path"])
            return response.json()["full_path"]
        else:
            return None
    ##################################################################################
    def list_groups(self):
        """List all groups in the GitLab instance."""
        groups = []
        gitlab_url = f"{self.url}/api/v4/groups/{self.group_id}/subgroups"
        page_int = 0
        got_pages = True
        print("Fetching groups for", gitlab_url, end=" ", flush=True)
        while got_pages:
            page_int += 1
            print("...", end="", flush=True)
            response = requests.get(gitlab_url, headers=self.headers, data={"page":page_int, "include_subgroups" : True})
            if response.status_code == 200:
                if len(response.json()) == 0:
                    got_pages = False
                for val in response.json():
                    full_path = val["full_path"]
                    groups.append(full_path)
            else:
                print(f"Failed to fetch projects: {response.status_code}")
                got_pages = False
        print("")
        return groups
    ##################################################################################
    def tokenise_server(self, server):
        git_server = server.replace("https://",f"https://oauth2:{self.token}@")
        return git_server
##########################################
#Author: Rachel Alcraft
#Edit: 15-03-2025 - RA: Initial version



THROTTLE_STATUS = 0.01
THROTTLE_PULL = 0.05
KEEPS = 10


##################################################################################
def git_pull_all(params, action, dry,debug, to_pull, file_size):
    threads_to_pull = list()
    scrch = Scratch(params["path"])
    count = 0
    if to_pull == None:
        to_pull = scrch.gits
    for gpath in to_pull:
        count += 1
        msg = f"{count}/{len(to_pull)}:"
        if not os.path.exists(gpath):
            print(f"Path {gpath} does not exist")
            continue
        else:
            msg += f"{action} from {gpath}"
            if dry:
                print(f"Dry: would {action} {gpath}")
            else:
                if params["multi"]:
                    x = None
                    if action == "pull":
                        time.sleep(THROTTLE_PULL)
                        x = threading.Thread(target=git_pull, args=(gpath, msg,file_size, debug))
                    elif action == "status":
                        time.sleep(THROTTLE_STATUS)
                        x = threading.Thread(target=git_status, args=(gpath, msg,debug))
                    elif action == "history":
                        time.sleep(THROTTLE_STATUS)
                        x = threading.Thread(target=git_history, args=(gpath, msg,debug))
                    elif action == "filesize":
                        time.sleep(THROTTLE_STATUS)
                        x = threading.Thread(target=git_filesize, args=(gpath, msg, file_size, True, debug))
                    elif action == "gitignore":
                        time.sleep(THROTTLE_STATUS)
                        x = threading.Thread(target=git_ignore, args=(gpath, msg, debug))
                    if x != None:
                        threads_to_pull.append(x)
                        x.start()
                else:
                    if action == "pull":
                        git_pull(gpath, msg,file_size,debug)
                    elif action == "status":
                        git_status(gpath, msg,debug)
                    elif action == "history":
                        git_status(gpath, msg,debug)
                    elif action == "filesize":
                        git_filesize(gpath, msg, file_size, True, debug)
                    elif action == "gitignore":
                        git_ignore(gpath, msg, debug)
    if params["multi"]:
        for index, thread in enumerate(threads_to_pull):
            thread.join()
    if count > 0:
        print()
    print(f"{action}ed {count} projects")
    print("=====================================")
##################################################################################
def git_clone_all(params, dry,debug, to_clone):
    threads_to_pull = list()
    scrch = Scratch(params["path"])
    count = 0
    for phttps, gpath in to_clone:
        count += 1
        msg = f"{count}/{len(to_clone)}:"
        msg += f"clone from {gpath}"
        if dry:
            print(f"Dry: would 'git clone {phttps} {gpath}'")
        else:
            if params["multi"]:
                    time.sleep(THROTTLE_PULL)
                    x = None
                    x = threading.Thread(target=git_clone, args=(phttps, gpath, msg, debug))
                    if x != None:
                        threads_to_pull.append(x)
                        x.start()
            else:
                git_clone(phttps, gpath, msg, debug)
    if params["multi"]:
        progress = 0
        for index, thread in enumerate(threads_to_pull):
            progress += 1
            thread.join()
            #print(f"Cloned: {progress}/{len(threads_to_pull)}")
    if count > 0:
        print()
    print(f"cloned {count} projects")
    print("=====================================")
##################################################################################
def git_clone(phttps, spath, msg, debug):
    keep_going = True
    count = 0
    while keep_going and count < KEEPS:
        count += 1
        process = subprocess.run(["git", "clone", phttps, spath],stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        if debug:
            print(f"git clone {phttps} {spath}")
        keep_going = git_message(process, msg,True, count == KEEPS)
        if keep_going:
            #if count%20 == 0:
            #    print("Retrying", phttps, count, "/" , KEEPS)
            time.sleep(1)
    if keep_going:
        print(f"\nFailed to clone {phttps} to {spath}")
        return False
    elif count > 1:
        print(f"\n{phttps} succeeded after {count} times")
    return True
##################################################################################
def git_pull(gpath, msg, file_size, debug):
    git_filesize(gpath, msg, file_size, False, debug)
    keep_going = True
    count = 0
    while keep_going and count < KEEPS:
        count += 1
        process = subprocess.run(["git", "-C", gpath, "pull"],stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        keep_going = git_message(process, msg, debug, count == KEEPS)
        if keep_going:
            #if count%20 == 0:
            #    print("Retrying", gpath, count)
            time.sleep(0.05)
    if keep_going:
        print(f"\nFailed to pull {gpath}")
        return False
    elif count > 10:
        print(f"\n{gpath} succeeded after {count} times")
    return True
########################################################################
def git_filesize(gpath, msg, file_size, full_msg, debug):
    gitignore = []
    ignore_history = False
    for root, dirs, files in os.walk(gpath):
        if ignore_history and '.git' in dirs:
            dirs.remove('.git')
        for filename in files:
            file_path = Path(root) / filename.replace(gpath,"")
            if file_path.stat().st_size > file_size:
                gitignore.append((str(file_path).strip(),file_path.stat().st_size))
    gitignore_path = Path(gpath) / ".gitignore"
    if len(gitignore) > 0:
        if full_msg:
            print(f"\nThe following files are larger than {file_size} bytes in {gpath}:")
            for gi, sz in gitignore:
                print("\t",sz, gi)
        existing = []
        with open(gitignore_path, "a+") as f:
            f.seek(0)
            existing = f.read().splitlines()
        existing = [line.strip() for line in existing]
        gitignore_2 = []
        for gi,sz in gitignore:
            rel_path = os.path.relpath(gi, gpath)
            if rel_path not in existing:
                gitignore_2.append(rel_path)
        if len(gitignore_2) > 0:
            print(f"\tAdding {len(gitignore_2)} files to .gitignore in {gpath}")
        if not debug:
            with open(gitignore_path, "a") as f:
                for gi in gitignore_2:
                    print(f"\t\tNew file to add {rel_path}")
                    f.write(gi + "\n")
    return False
def git_ignore(gpath, msg, debug):
    gitignore_path = Path(gpath) / ".gitignore"
    if gitignore_path.exists():
        print(f"\nThis repo has a gitignore {gpath}")
        with open(gitignore_path, "r") as f:
            for line in f:
                line = line.strip()
                if line != "":
                    print("\t",line)
    return False
##################################################################################
def git_status(gpath, msg, debug):
    process = subprocess.run(["git", "-C", gpath, "status"], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    git_message(process, msg, debug)
##################################################################################
def git_history(gpath, msg, debug):
    process = subprocess.run(["git", "-C", gpath, "log", "-2", "--pretty=format:'%h%x09%an%x09%ad%x09%s'"],stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    git_message(process, msg, debug)
##################################################################################
def git_message(process, msg, debug, force_msg=False):
    connection_error = False
    out = process.stdout.decode("utf-8").strip()
    err = process.stderr.decode("utf-8").strip()

    if "Resource temporarily unavailable" in err:
        print("\n\nAre you accidentally running on the login node?")
        print("\tThere are not enough resources, you can turn of multithreading with --single")
        raise SystemExit
    if "thread failed to start" in err:
        print("\n\nAre you accidentally running on the login node?")
        print("\tThere are not enough resources, you can turn of multithreading with --single")
        raise SystemExit
    if "can't start new thread" in err:
        print("\n\nAre you accidentally running on the login node?")
        print("\tThere are not enough resources, you can turn of multithreading with --single")
        raise SystemExit

    # strip out err msg from ssh key
    err = err.replace('\\220',"").replace('\\230',"").replace('\\342',"").replace('\\225',"")
    err = err.replace('\\224',"").replace('\\202',"").replace('\\233',"").replace('\\222',"")
    err = err.replace("UNAUTHORISED ACCESS TO THIS APPLIANCE IS PROHIBITED!","")
    err = err.replace("This appliance, and associated systems, are for ICR authorised users only.","")
    err = err.replace("Unauthorised or improper use may result in disciplinary action, and/or","")
    err = err.replace("civil or criminal prosecution under the Computer Misuse Act (1990). By","")
    err = err.replace("continuing, you agree to abide by the terms of the ICR Acceptable Use","")
    err = err.replace("Policy (published on NEXUS). All use is monitored, and users have no","")
    err = err.replace("implicit or explicit expectation of privacy. Please contact ICR","")
    err = err.replace("Information Security (infosec@icr.ac.uk) for more information.","")
    #err = err.replace(" ","")
    #err = err.replace("\n","")
    if err.upper() == err.lower():
        err = ""
    #err = err.replace("\t","")
    if "Connection reset by peer" in err and not force_msg:
        connection_error = True
        print("-", end="", flush=True)
    elif "fatal: Could not read from remote repository" in err and not force_msg:
        connection_error = True
        print("-", end="", flush=True)
    else:
        out = out.replace("Already up to date.","")
        out = out.replace("On branch main","")
        out = out.replace("Your branch is up to date with 'origin/main'.","")
        out = out.replace("nothing to commit, working tree clean","")
        out = out.strip()
        if out.upper() == out.lower():
            out = ""
        outs = out.split("\n")
        out2 = "\n\t".join(outs).strip()
        errs = err.split("\n")
        if len(errs) > 2:#skip the security message
            if "UNAUTHORISED ACCESS" in err:
                errs = errs[11:]
        err2 = "\n\t".join(errs).strip()
        if out2 == "" and err2 == "" and not debug:
            print(".", end="", flush=True)
        else:
            if out2 != "":
                msg += f"\n\t{out2}"
            if err2 != "":
                if err2 != "":
                    msg += f"\n\t{err2}"
            print("\n",msg, end="", flush=True)
    return connection_error
##################################################################################
def git_change_protocol(params, new_protocol, dry, debug,token, minimal=False):
    scrch = Scratch(params["path"])
    server = params["server"]
    to_change = scrch.gits
    count = 0
    for ch in to_change:
        git_config_file = Path(ch) / ".git" / "config"
        if not git_config_file.exists():
            print(f"Path {git_config_file} does not exist")
            continue
        else:
            with open(git_config_file, "r") as f:
                lines = f.readlines()

            new_lines = []
            for line in lines:
                if "url =" in line:
                    would_change = False
                    if "oauth2" in line:
                        if new_protocol == "https":
                            old,line = pat_to_https(line)
                            would_change = old != line
                        elif new_protocol == "ssh":
                            old,line = pat_to_ssh(line, server)
                            would_change = old != line
                        elif new_protocol == "pat":
                            old,line = pat_to_pat(line,token)
                            would_change = old != line
                    elif "https://" in line:
                        if new_protocol == "pat":
                            old,line = https_to_pat(line,token)
                            would_change = old != line
                        elif new_protocol == "ssh":
                            old,line = https_to_ssh(line, server)
                            would_change = old != line
                    elif "git@" in line:
                        if new_protocol == "pat":
                            old,line = ssh_to_pat(line,server, token)
                            would_change = old != line
                        elif new_protocol == "https":
                            old,line = ssh_to_https(line, server)
                            would_change = old != line
                    if would_change:
                        count += 1
                        if dry:
                            print("would replace:", line)
                        else:
                            print("replacing:", line.strip())

                new_lines.append(line)

            if not dry:
                with open(git_config_file, "w") as f:
                    for line in new_lines:
                        f.write(line)

    if count > 0:
        print(f"changed {count} repo protocols")
    return True
##################################################################################
def ssh_to_pat(line, server, token):
    old = line
    server_trunk = server.replace("https://","")
    line = line.replace(f"git@{server_trunk}:", f"https://oauth2:{token}@{server_trunk}/")
    return old,line
##################################################################################
def https_to_pat(line,token):
    old = line
    line = line.replace("https://",f"https://oauth2:{token}@")
    return old,line
##################################################################################
def https_to_ssh(line, server):
    old = line
    server_trunk = server.replace("https://","")
    line = line.replace(f"https://{server_trunk}/",f"git@{server_trunk}:")
    line = line.replace(f"git@{server_trunk}/", f"git@{server_trunk}:")
    return old,line
##################################################################################
def ssh_to_https(line, server):
    old = line
    server_trunk = server.replace("https://","")
    line = line.replace(f"git@{server_trunk}:", f"https://{server_trunk}/")
    return old,line
##################################################################################
def pat_to_ssh(line, server):
    old = line
    server_trunk = server.replace("https://","")
    lineA = line.split("https://")[0]
    lineB = line.split("@")[1]
    line = lineA + "git@" + lineB
    line = line.replace(f"git@{server_trunk}/", f"git@{server_trunk}:")
    return old,line
##################################################################################
def pat_to_https(line):
    old = line
    lineA = line.split("https://")[0]
    lineB = line.split("@")[1]
    line = lineA + "https://" + lineB
    return old,line
##################################################################################
def pat_to_pat(line,token):
    old = line
    lineA = line.split("https://")[0]
    lineB = line.split("@")[1]
    line =  lineA + f"https://oauth2:{token}@" + lineB
    return old,line
##################################################################################
##########################################
#Author: Rachel Alcraft
#Edit: 15-03-2025 - RA: Initial version




##################################################################################
### Command line parsing ###
def gh_args(args,params):
    params["path"] = os.getcwd() if not args.path else args.path
    params["multi"] = False if args.single else True
    params["root"] = True if args.root else False
    return params
##################################################################################
def gh_clone_projects(params, dry,debug, all_projects=[]):
    print(f"---Gathering projects--- ")
    api = GitHubAPI(params["repos"], params["server"])
    to_clone = []
    to_pull = []
    if all_projects == []:
        all_projects = api.list_projects()
    root_path = params["path"]
    home_path = params["home"]
    scrch = Scratch(root_path)
    repo_len = 0
    projects = scrch.get_child_projects(all_projects,repo_len)
    count = 0
    cloned = 0
    for project in projects:
        count += 1
        phttps = project[0]
        ppath = project[2]
        gpath = f"{home_path}/{'/'.join(ppath.split('/')[repo_len:])}"
        spath = f"{home_path}/{'/'.join(ppath.split('/')[repo_len:-1])}"
        if root_path in gpath:
            if params["protocol"] == "ssh":
                phttps = phttps.replace("https://","git@")
            if not os.path.exists(gpath):
                os.makedirs(spath, exist_ok=True)
                to_clone.append((phttps, gpath))
            else:
                to_pull.append(gpath)
    return to_clone, to_pull
##################################################################################
##########################################
#Author: Rachel Alcraft
#Edit: 15-03-2025 - RA: Initial version


##################################################################################
### Command line parsing ###
def gl_clone_args(args,params):
    params["path"] = os.getcwd() if not args.path else args.path
    params["multi"] = False if args.single else True
    params["root"] = True if args.root else False
    return params
##################################################################################
def gl_clone_projects(params, dry,debug, all_projects=[]):
    print(f"---Gathering projects--- ")
    api = GitLabAPI(params["subgroup"], params["server"], params["wikis"], False)
    repo_len = api.repo_len
    if all_projects == []:
        all_projects,archived = api.list_projects()
    root_path = params["path"]
    home_path = params["home"]
    scrch = Scratch(root_path)
    projects = scrch.get_child_projects(all_projects,repo_len)
    count = 0
    cloned = 0
    to_clone = []
    to_pull = []
    for project in projects:
        count += 1
        phttps = project[0]
        ppath = project[2]
        spath = f"{home_path}/{'/'.join(ppath.split('/')[repo_len:-1])}"
        gpath = f"{home_path}/{'/'.join(ppath.split('/')[repo_len:])}"
        if root_path in gpath:
            if params["protocol"] == "ssh":
                phttps = phttps.replace("https://git.icr.ac.uk/","git@git.icr.ac.uk:")
            elif params["protocol"] == "pat":
                phttps = api.tokenise_server(phttps)
            if not os.path.exists(gpath):
                os.makedirs(spath, exist_ok=True)
                to_clone.append((phttps, gpath))
            else:
                to_pull.append(gpath)
            #if params["wikis"]:
            ##    # also looking for wikis
            #    gpath_wiki = f"{gpath}.wiki"
            #    wiki_url = phttps.replace(".git", ".wiki.git")
            #    if not os.path.exists(gpath_wiki):
            #        os.makedirs(gpath_wiki, exist_ok=True)
            #        print("Add wiki to clone", gpath_wiki, "from", phttps + ".wiki")
            #        to_clone.append((wiki_url, gpath_wiki))
            #    #else:
            #        #print("Add wiki to pull", gpath_wiki)
            #        #to_pull.append(gpath_wiki)
    return to_clone, to_pull
##################################################################################
def gl_clone_clean(params, dry, all_projects=[]):
    api = GitLabAPI(params["subgroup"], params["server"], params["wikis"],False)
    repo_len = api.repo_len
    scrch = Scratch(params["path"])
    if all_projects == []:
        all_projects,archived = api.list_projects()
    projects = scrch.get_child_projects(all_projects,repo_len)
    projects_paths = []
    for project in projects:
        ppath = project[2]
        gpath = f"{params['home']}/{'/'.join(ppath.split('/')[repo_len:])}"
        projects_paths.append(str(gpath))
    count = 0
    for gpath in scrch.gits:
        if str(gpath) not in projects_paths:
            # check the status of the project
            print(f"\t~ Candidate to delete: {gpath} from {scrch.path}")
            # check if there are child git projects
            child_gits = scrch.get_gits(gpath)
            if len(child_gits) > 1:
                print(f"\t\t!!! Skipping {gpath}, is there an error in your configuration? This git folder has child gits.")
            else:
                process = subprocess.run(["git", "-C", gpath, "status"], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                outstr = process.stdout.decode("utf-8").strip()
                errstr = process.stderr.decode("utf-8").strip()

                if errstr != "":
                    print(f"\t\t!!! Error in git status for {gpath}: {errstr}, not deleting")
                elif "nothing to commit" in outstr:
                    count += 1
                    if dry:
                        print(f"\t\t~ dry: would delete {gpath}")
                    else:
                        print(f"\t~ deleting {gpath}/*")
                        subprocess.run(["rm", "-rf", gpath],stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                else:
                    print(f"\t!!! Project {gpath} has uncommitted changes, not deleting!!!")


    if count > 0:
        print()
    print(f"\tDeleted {count} projects")
    print("=====================================")
    return all_projects,archived
##################################################################################
##########################################
#Author: Rachel Alcraft
#Edit: 15-03-2025 - RA: Initial version


##################################################################################
### Command line parsing ###
def init_args(scrch, args):
    params = {}
    params["path"] = os.getcwd() if not args.path else args.path
    if not scrch.gitalma:
        scrch.home = str(params["path"])
    params["home"] = scrch.home
    params["source"] = "icr" if not args.source else args.source
    params["wikis"] = False if not args.wikis else args.wikis
    if str(params["wikis"]).lower() == "true":
        params["wikis"] = True
    elif str(params["wikis"]).lower() == "false":
        params["wikis"] = False
    if params["source"] == "icr":
        params["server"] = "https://git.icr.ac.uk" if not args.server else args.server
    elif params["source"] == "gitlab":
        params["server"] = "https://gitlab.com" if not args.server else args.server
    elif params["source"] == "github":
        params["server"] = "https://github.com" if not args.server else args.server
    else:
        params["server"] = "https://git.icr.ac.uk" if not args.server else args.server
    if params["source"] == "gitlab" or params["source"] == "icr":
        params["protocol"] = "pat" if not args.protocol else args.protocol
    else:
        params["protocol"] = "https" if not args.protocol else args.protocol
    params["subgroup"] = -1 if not args.subgroup else args.subgroup
    return params
##################################################################################
def cmd_args(args):
    params = {}
    params["path"] = os.getcwd() if not args.path else args.path
    if args.protocol:
        params["protocol"] = args.protocol
    return params
##################################################################################
def init_check_get(scrch,params):
    init_params = {}
    init_path = f"{scrch.home}/.gitalma/init.yaml"
    if os.path.exists(init_path):
        with open(init_path, "r") as yaml_file:
            init_params = yaml.safe_load(yaml_file)#, Loader=yaml.FullLoader)
    return init_params
##################################################################################
def init_save(new_params, orig_params, api=None):
    init_path = f"{new_params['home']}/.gitalma"
    os.makedirs(init_path, exist_ok=True)
    init_file = f"{new_params['home']}/.gitalma/init.yaml"
    changed_params = {}
    # put orig params in first then any overwrites
    for key in orig_params:
        changed_params[key] = orig_params[key]
    for key in new_params:
        if key in changed_params:
            if orig_params[key] != new_params[key]:
                print(f"Changing {key} from {orig_params[key]} to {new_params[key]}")
        if key == "home":
            changed_params[key] = str(new_params[key])
        elif key == "wikis" or key == "multi" or key == "root":
            if str(new_params[key]).lower() == "true":
                changed_params[key] = True
            elif str(new_params[key]).lower() == "false":
                changed_params[key] = False
            else:
                changed_params[key] = new_params[key]
        else:
            changed_params[key] = new_params[key]
    # now do a sanity check on the matching names of the path and groupip
    if changed_params["source"] in ["gitlab","icr"] and api is not None:
        gp, rp = api.get_id_repo()
        changed_params["subgroup"] = gp
        changed_params["repo"] = rp

    with open(init_file, "w") as yaml_file:
        yaml.dump(changed_params, yaml_file, default_flow_style=False, indent=4, width=80, sort_keys=False)

    return changed_params
##################################################################################
def init_print(params,init):
    print("-------------------------------------")
    if init:
        print("Initialised the settings for gitlab or github")
    else:
        print("The existing settings for gitlab or github")
    print("-------------------------------------")
    for key in params:
        num_tabs = 2 - len(key)//8
        print(key, num_tabs*"\t",params[key])
##################################################################################














##########################################


class Scratch:
    def __init__(self, path):
        self.path = path
        self.gitalma = False
        self.gitalmaparent = False
        self.get_home()
        self.gits = self.get_gits()
    ##################################################################################
    def get_home(self):
        """Find the parent gitalma home."""
        #Check if the given path is a Git repository or its child."""
        gitlabpath = Path(self.path).resolve()
        self.working = os.getcwd()
        self.home = None

        all_gitalmas = []
        child_gitalmas = []

        for gitlab_path in [gitlabpath, *gitlabpath.parents]:
            if os.path.exists(os.path.join(gitlab_path, ".gitalma")):
                self.gitalma = True
                all_gitalmas.append(str(gitlab_path))
        #remove home
        if self.gitalma:
            self.home =  all_gitalmas[-1]
            x_alma = [x for x in all_gitalmas if str(x) != str(self.home)]
            if len(x_alma) > 0 and self.gitalma:
                print(f"\tfound {len(x_alma)} sub gitalma homes in {self.home}")
                for xa in x_alma:
                    full_path = xa + "/.gitalma"
                    if os.path.exists(full_path):
                        print("\t\tdeleting sub gitalma home", full_path)
                        os.system(f"rm -rf {full_path}")
        else:
            # look for a child gitalma, use a recursive path to find a chhild gitalma
            gitalmas = glob.glob(f"{self.path}/**/.gitalma", recursive=True)
            if len(gitalmas) > 0:
                print(f"\tfound {len(gitalmas)} gitalma repos beneath {self.path}")
                self.gitalmaparent = True
                child_gitalmas = [str(gitalmas[0])]
    ##################################################################################
    def get_gits(self, root = None):
        """Find all the gitalma homes in the parent directory."""
        if not root:
            gitlabpath = Path(self.path).resolve()
        else:
            gitlabpath = Path(root).resolve()
        gits = []
        # find all the child folders that have a .git direcrorty
        subfolders = [f for f in gitlabpath.iterdir() if f.is_dir()] + [gitlabpath]
        while len(subfolders) > 0:
            subfolder = subfolders.pop()
            if os.path.exists(os.path.join(subfolder, ".git")):
                gits.append(str(subfolder))
            else:
                subfolders.extend([f for f in subfolder.iterdir() if f.is_dir()])
        for g in range(len(gits)):
            gits[g] = str(gits[g])
        # make sure this is a unique list
        gits = list(set(gits))
        # sort the list
        gits.sort()
        return gits
    ##################################################################################
    def get_subgroups(self, groups, repo_len):
        sgps = []
        for gp in groups:
            gpath = f"{self.home}/{'/'.join(gp.split('/')[repo_len:])}"
            sgps.append(gpath)
        return sgps
    ##################################################################################
    def get_child_projects(self, projects, repo_len):
        child_projects = []
        for project in projects:
            gpath = f"{self.home}/{'/'.join(project[2].split('/')[repo_len:])}"
            if gpath.startswith(self.path):
                child_projects.append(project)
        return child_projects
    ##################################################################################




##########################################

LVERSION  = '1.2.0'

def get_github_version():
    # get the file contents of the github file
    version = "0.0.0"
    try:
        url = "https://raw.githubusercontent.com/ICR-RSE-Group/gitalma/refs/heads/main/pyproject.toml"
        response = requests.get(url)
        if response.status_code == 200:
            lines = response.content.decode("utf-8").split("\n")
            for line in lines:
                if "version" in line:
                    version = line.split("=")[1].strip().replace('"','')
                    return version
        else:
            print("Failed to download cli.py")
    except:
        pass
    return version

def get_local_version():
    if LVERSION == "":
        return get_gitalma_version()
    else:
        return LVERSION

def get_gitalma_version():
    version = ""
    process = subprocess.run(["python3","-m","pip", "show","gitalma","|","grep","Version"],stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    lines = process.stdout.decode('utf-8').strip().split('\n')
    for line in lines:
        if "Version" in line:
            version = line.split(":")[1].strip()
            return version
    return version


##########################################

if __name__ == "__main__":
    import sys
    # --------------------------------------------
    # Temporarily do a pat change before running the command
    current_dir = os.getcwd().lower()
    tmp_sys_arg = []
    for arg in sys.argv:
        tmp_sys_arg.append(arg)
    sys.argv = sys.argv[:1] + ["change", "-protocol","pat", "--minimal"]
    main()
    sys.argv = tmp_sys_arg
    # --------------------------------------------
    if len(sys.argv) == 1:
        sys.argv.append("update")
    elif sys.argv[1] == "--status":
        sys.argv[1] = "status"
    main()

##########################################

